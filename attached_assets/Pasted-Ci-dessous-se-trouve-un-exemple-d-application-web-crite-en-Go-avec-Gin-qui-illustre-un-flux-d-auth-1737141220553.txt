Ci-dessous se trouve un exemple d’application web écrite en Go avec Gin, qui illustre un flux d’authentification OAuth2 (PKCE) vers Twitter (désormais X). Cet exemple reprend l’idée générale du projet Rust (lancer la phase d’authentification, écouter la redirection /callback, échanger le code contre un jeton, etc.) mais utilise les outils Go.

Il s’agit d’un simple point de départ : vous pouvez l’adapter pour gérer l’OAuth 1.0a, stocker vos jetons en base, ajouter des middlewares, etc. De plus, dans la mesure où Twitter/X évolue rapidement, vérifiez bien les dernières spécifications de leur API et leurs URL d’authentification.

Structure minimale des fichiers

Pour rester proche de l’esprit du projet Rust, on peut imaginer l’arborescence suivante :

myapp/
├── .github/
│   └── workflows/
│       ├── release.yml       # éventuellement adapté à Go
│       └── ci.yml            # workflow CI pour Go
├── .gitignore
├── go.mod
├── go.sum
├── main.go
└── README.md

Exemple de .gitignore

# Binaire principal
myapp

# Répertoires Go
bin/
pkg/

Exemple de workflows GitHub Actions

Vous pouvez largement réutiliser la logique de vos fichiers release.yml et rust.yml.
Voici un exemple simplifié pour Go :

# .github/workflows/ci.yml
name: Go CI

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build-and-test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v4
        with:
          go-version: '1.20'

      - name: Install dependencies
        run: go mod download

      - name: Build
        run: go build -v .

      - name: Test
        run: go test -v ./...

Pour la partie release, vous pourriez vous inspirer de taiki-e/create-gh-release-action et taiki-e/upload-rust-binary-action, mais adaptés à des exécutables Go.

Fichier main.go

Voici un code Go (Gin) qui montre un flux OAuth2 (avec PKCE) vers l’API de Twitter (nommée X). Il :
	1.	Lance un serveur Gin.
	2.	Expose un endpoint /login qui redirige l’utilisateur vers Twitter avec les bons paramètres (client_id, code_challenge, etc.).
	3.	Expose un endpoint /callback qui reçoit le code envoyé par Twitter, ainsi que le state (optionnel).
	4.	Échange ce code contre un token d’accès via l’endpoint token de Twitter.
	5.	Affiche les informations de l’utilisateur récupérées sur l’endpoint https://api.x.com/2/users/me (en guise d’exemple).

Vous devrez :
	•	Renseigner vos valeurs de CLIENT_ID et CLIENT_SECRET (ou les injecter en variables d’environnement).
	•	Configurer votre application sur developer.twitter.com pour utiliser le flux OAuth2.
	•	Déclarer la bonne URL de callback (ici http://localhost:8080/callback).

Remarque: La bibliothèque standard golang.org/x/oauth2 ne gère pas nativement le PKCE. On doit donc construire manuellement la code_challenge et la code_verifier.

main.go

package main

import (
	"bytes"
	"context"
	"crypto/rand"
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"log"
	"net/http"
	"os"

	"github.com/gin-gonic/gin"
)

// Configuration minimale pour l’OAuth2 Twitter
var (
	clientID     = os.Getenv("CLIENT_ID")       // À définir dans l'env
	clientSecret = os.Getenv("CLIENT_SECRET")   // À définir dans l'env

	// URL d’autorisation (pour Twitter / X)
	authURL  = "https://x.com/i/oauth2/authorize"
	tokenURL = "https://api.x.com/2/oauth2/token"

	// URL de callback déclaré sur l’app Twitter
	redirectURI = "http://localhost:8080/callback"

	// URL pour récupérer des infos utilisateur
	userInfoURL = "https://api.x.com/2/users/me"

	// Scopes OAuth2 demandés (à adapter selon vos besoins)
	oauthScopes = "tweet.read users.read follows.read offline.access" // exemple

	// En production, on stocke plutôt la codeVerifier en BDD ou session. Ici on fait simple.
	codeVerifier = ""
)

// tokenResponse représente le JSON renvoyé par /2/oauth2/token
type tokenResponse struct {
	TokenType    string `json:"token_type"`
	ExpiresIn    int    `json:"expires_in"`
	AccessToken  string `json:"access_token"`
	Scope        string `json:"scope"`
	RefreshToken string `json:"refresh_token,omitempty"`
}

// userResponse représente un extrait possible du JSON renvoyé par /2/users/me
type userResponse struct {
	Data struct {
		ID       string `json:"id"`
		Name     string `json:"name"`
		Username string `json:"username"`
	} `json:"data"`
}

// createCodeVerifier génère un code_verifier aléatoire pour PKCE
func createCodeVerifier() (string, error) {
	// Selon la spec, entre 43 et 128 chars. Ici on prend 50.
	b := make([]byte, 50)
	_, err := rand.Read(b)
	if err != nil {
		return "", err
	}
	// Encodage base64 "URL-safe" sans padding
	return base64.RawURLEncoding.EncodeToString(b), nil
}

// codeChallengeFromVerifier calcule le code_challenge (S256) à partir du code_verifier
func codeChallengeFromVerifier(verifier string) string {
	sum := sha256.Sum256([]byte(verifier))
	return base64.RawURLEncoding.EncodeToString(sum[:])
}

func main() {
	if clientID == "" || clientSecret == "" {
		log.Fatal("CLIENT_ID et/ou CLIENT_SECRET non définis dans l'environnement.")
	}

	router := gin.Default()

	// Page d’accueil
	router.GET("/", func(c *gin.Context) {
		c.String(http.StatusOK, "Bienvenue sur l’exemple OAuth2 PKCE (Go/Gin). Allez sur /login pour commencer.")
	})

	// Endpoint /login : redirection vers l’écran de connexion Twitter
	router.GET("/login", func(c *gin.Context) {
		verifier, err := createCodeVerifier()
		if err != nil {
			c.String(http.StatusInternalServerError, "Erreur génération code_verifier: %v", err)
			return
		}
		codeVerifier = verifier

		challenge := codeChallengeFromVerifier(codeVerifier)
		// On peut éventuellement générer un "state" pour se protéger des attaques CSRF.
		state := "xyz123" // exemple simple

		// Contruire l’URL d’autorisation
		u := fmt.Sprintf(
			"%s?response_type=code&client_id=%s&redirect_uri=%s&scope=%s&state=%s&code_challenge=%s&code_challenge_method=S256",
			authURL,
			clientID,
			redirectURI,
			oauthScopes,
			state,
			challenge,
		)

		// Redirection
		c.Redirect(http.StatusFound, u)
	})

	// Endpoint /callback : Twitter redirige ici avec ?code=xxx&state=xyz123
	router.GET("/callback", func(c *gin.Context) {
		code := c.Query("code")
		state := c.Query("state")
		if code == "" {
			c.String(http.StatusBadRequest, "Missing code in query parameters")
			return
		}
		// On pourrait vérifier que le state correspond à celui qu’on a envoyé
		log.Printf("Code reçu: %s, state=%s", code, state)

		// Échange du code contre un token
		resp, err := exchangeCodeForToken(code, codeVerifier)
		if err != nil {
			c.String(http.StatusInternalServerError, "Erreur échange du code: %v", err)
			return
		}

		// On a un Access Token. On peut interroger l’API X/Twitter
		userInfo, err := fetchUserInfo(resp.AccessToken)
		if err != nil {
			c.String(http.StatusInternalServerError, "Erreur récupération info user: %v", err)
			return
		}

		message := fmt.Sprintf("Authentification OK !\nToken: %s\nUser: @%s (ID: %s, Name: %s)",
			resp.AccessToken,
			userInfo.Data.Username,
			userInfo.Data.ID,
			userInfo.Data.Name,
		)
		c.String(http.StatusOK, message)
	})

	// Lancement du serveur
	log.Println("Serveur lancé sur :8080 ...")
	if err := router.Run(":8080"); err != nil {
		log.Fatal(err)
	}
}

// exchangeCodeForToken échange le code d’auth contre un Access Token
func exchangeCodeForToken(code, verifier string) (*tokenResponse, error) {
	// Préparation de la requête POST vers /2/oauth2/token
	// Paramètres imposés par Twitter pour PKCE
	form := fmt.Sprintf(
		"grant_type=authorization_code&code=%s&client_id=%s&redirect_uri=%s&code_verifier=%s",
		code,
		clientID,
		redirectURI,
		verifier,
	)
	req, err := http.NewRequest(http.MethodPost, tokenURL, bytes.NewBufferString(form))
	if err != nil {
		return nil, err
	}
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")

	// Basic Auth avec le client_secret
	req.SetBasicAuth(clientID, clientSecret)

	client := &http.Client{}
	res, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	bodyBytes, _ := io.ReadAll(res.Body)
	if res.StatusCode < 200 || res.StatusCode >= 300 {
		return nil, fmt.Errorf("Twitter token endpoint returned status %d: %s", res.StatusCode, string(bodyBytes))
	}

	var tokenResp tokenResponse
	if err := json.Unmarshal(bodyBytes, &tokenResp); err != nil {
		return nil, err
	}
	return &tokenResp, nil
}

// fetchUserInfo appelle l’endpoint /2/users/me pour avoir des infos sur l’utilisateur
func fetchUserInfo(accessToken string) (*userResponse, error) {
	ctx := context.Background()

	req, err := http.NewRequestWithContext(ctx, http.MethodGet, userInfoURL, nil)
	if err != nil {
		return nil, err
	}
	req.Header.Set("Authorization", "Bearer "+accessToken)

	client := &http.Client{}
	res, err := client.Do(req)
	if err != nil {
		return nil, err
	}
	defer res.Body.Close()

	bodyBytes, _ := io.ReadAll(res.Body)
	if res.StatusCode < 200 || res.StatusCode >= 300 {
		return nil, fmt.Errorf("Twitter user info returned status %d: %s", res.StatusCode, string(bodyBytes))
	}

	var user userResponse
	if err := json.Unmarshal(bodyBytes, &user); err != nil {
		return nil, err
	}
	return &user, nil
}

go.mod minimal

Dans votre répertoire myapp/ :

go mod init github.com/votrecompte/myapp
go mod tidy

Ce qui créera un fichier go.mod du style :

module github.com/votrecompte/myapp

go 1.20

require (
    github.com/gin-gonic/gin v1.9.0
)

(Les numéros de version peuvent différer.)

Explications
	1.	Variables d’environnement
	•	CLIENT_ID et CLIENT_SECRET doivent être définis dans l’environnement pour que l’exemple fonctionne. Sinon, le programme sortira avec une erreur.
	2.	Endpoints
	•	GET /login : génère un code_verifier, en déduit un code_challenge, puis redirige vers Twitter.
	•	GET /callback : Twitter renvoie sur cette URL avec ?code=.... On l’échange ensuite contre un token via exchangeCodeForToken, puis on appelle fetchUserInfo pour illustrer la récupération d’infos utilisateur.
	3.	PKCE
	•	On génère un code_verifier aléatoire (50 octets).
	•	On crée un code_challenge en prenant SHA256(code_verifier), puis en base64-url-encodé (sans padding).
	•	Dans un vrai projet, il faudra gérer des sessions (cookies) ou un stockage en base, pour éviter d’avoir le code verifier en variable globale.
	4.	Scopes
	•	Dans l’exemple, on a mis tweet.read users.read follows.read offline.access. À adapter suivant vos besoins et ce que vous avez configuré dans le developer portal.
	5.	Stockage du token
	•	L’exemple se contente d’afficher le token et l’utilisateur.
	•	Dans une vraie application, on stocke le token (et éventuellement le refresh_token) dans un endroit sûr (base de données, Redis, etc.) associé à l’utilisateur.

Pour aller plus loin
	•	OAuth 1.0a : si vous souhaitez implémenter aussi l’authentification OAuth 1.0a (legacy), vous pouvez reprendre la logique du projet Rust et signer les requêtes HTTP avec la signature HMAC-SHA1. Mais aujourd’hui, l’OAuth2 est largement privilégié.
	•	Sécuriser le “state” : pour mieux contrer les attaques CSRF, on associe un state généré aléatoirement à chaque session. On le stocke en session et on le vérifie au retour du callback.
	•	Refresh token : l’exemple récupère le refresh_token, vous pouvez implémenter un endpoint pour actualiser le access_token sans repasser par /login.
	•	Gestion d’erreurs plus poussée : en production, affichez des messages plus adaptés, et loggez proprement.

Voilà un squelette fonctionnel en Go/Gin qui reproduit, dans les grandes lignes, le comportement d’authentification du code Rust montré dans votre question. Il vous reste à l’adapter selon votre use-case (stockage, UI, etc.). Bonne continuation !